import pygetwindow as gw
import mss
import matplotlib.pyplot as plt
import cv2
import numpy as np
import time
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Conv2D,Flatten,MaxPooling2D
from tensorflow.keras.callbacks import ModelCheckpoint
import pyautogui
import tensorflow_datasets as tfds

path="C:/Users/Dell/Desktop/Ahmed ki bla/Ahmed Programs/Model Checkpoints/checkpoint1.weights.h5"
check=ModelCheckpoint(filepath=path,save_best_only=True,save_weights_only=True,verbose=1)
model = tf.keras.Sequential([
    tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dense(10, activation='softmax')  # 10 classes (digits 0-9)
])

model.compile(optimizer="adam",loss="sparse_categorical_crossentropy", metrics=["accuracy"])


print("Do you want to load model? (y/n): ")
ans = input()
if ans.lower() != "y":
    # Load MNIST
    (mnist_train_images, mnist_train_labels), (mnist_test_images, mnist_test_labels) = tf.keras.datasets.mnist.load_data()

    # Load EMNIST/digits
    emnist_data = tfds.load("emnist/digits", split=["train", "test"], as_supervised=True)

    # Convert EMNIST data from TensorFlow dataset to numpy arrays
    emnist_train_images, emnist_train_labels = [], []
    emnist_test_images, emnist_test_labels = [], []

    for img, label in tfds.as_numpy(emnist_data[0]):  # Train split
        emnist_train_images.append(img)
        emnist_train_labels.append(label)

    for img, label in tfds.as_numpy(emnist_data[1]):  # Test split
        emnist_test_images.append(img)
        emnist_test_labels.append(label)

    # Convert lists to numpy arrays
    emnist_train_images = np.array(emnist_train_images)
    emnist_train_labels = np.array(emnist_train_labels)
    emnist_test_images = np.array(emnist_test_images)
    emnist_test_labels = np.array(emnist_test_labels)

    # Normalize pixel values (0-255) to (0-1)
    mnist_train_images = mnist_train_images / 255.0
    mnist_test_images = mnist_test_images / 255.0
    emnist_train_images = emnist_train_images / 255.0
    emnist_test_images = emnist_test_images / 255.0

    # Reshape to (batch_size, 28, 28, 1) for CNNs
    mnist_train_images = mnist_train_images.reshape(-1, 28, 28, 1)
    mnist_test_images = mnist_test_images.reshape(-1, 28, 28, 1)
    emnist_train_images = emnist_train_images.reshape(-1, 28, 28, 1)
    emnist_test_images = emnist_test_images.reshape(-1, 28, 28, 1)

    # Combine training sets
    combined_train_images = np.concatenate((mnist_train_images, emnist_train_images), axis=0)
    combined_train_labels = np.concatenate((mnist_train_labels, emnist_train_labels), axis=0)

    # Combine test sets
    combined_test_images = np.concatenate((mnist_test_images, emnist_test_images), axis=0)
    combined_test_labels = np.concatenate((mnist_test_labels, emnist_test_labels), axis=0)

    from sklearn.utils import shuffle
    combined_train_images, combined_train_labels = shuffle(combined_train_images, combined_train_labels)
    combined_test_images, combined_test_labels = shuffle(combined_test_images, combined_test_labels)
    history = model.fit(combined_train_images, combined_train_labels, epochs=5, validation_data=(combined_test_images, combined_test_labels), callbacks=[check])

else:
    model.load_weights(path)

import pygame
import numpy as np
import cv2

# --- Setup ---
pygame.init()
WIDTH, HEIGHT = 280, 280   # large canvas to draw on
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Draw a Digit")
clock = pygame.time.Clock()

# Drawing variables
drawing = False
brush_size = 12
screen.fill((0, 0, 0))  # black background

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

        elif event.type == pygame.MOUSEBUTTONDOWN:
            drawing = True
        elif event.type == pygame.MOUSEBUTTONUP:
            drawing = False

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RETURN:  # Press Enter to capture
                # Get pixel data from screen
                raw_pixels = pygame.surfarray.array3d(screen)
                gray = np.dot(raw_pixels[...,:3], [0.299, 0.587, 0.114])  # convert to grayscale
                gray = gray.swapaxes(0,1)  # fix pygame x/y orientation

                # Resize to 28x28 for CNN (like MNIST)
                img_resized = cv2.resize(gray, (28, 28), interpolation=cv2.INTER_AREA)

                # Normalize [0,1]
                img_resized = img_resized / 255.0

                img_input = img_resized.reshape(1, 28, 28, 1).astype("float32")

                predictions = model.predict(img_input)
                predicted_label = np.argmax(predictions)
                for i, prob in enumerate(predictions[0]):
                    print(f"Digit {i}: {prob*100:.2f}%")
                print("Highest Confidence: ", predicted_label)

                #print("Captured digit shape:", img_resized.shape)
                # Now you can feed `img_resized.reshape(1,28,28,1)` into your CNN

            elif event.key == pygame.K_c:  # Press C to clear
                screen.fill((0, 0, 0))

        # Draw when mouse is pressed
        if drawing:
            mouse_pos = pygame.mouse.get_pos()
            pygame.draw.circle(screen, (255, 255, 255), mouse_pos, brush_size)

        pygame.display.flip()
        clock.tick(60)

pygame.quit()
